# -*- coding: utf-8 -*-
"""EvaluatedModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XPy6t_iH2FUwSoleHG-Y8vjB55EgTu5q
"""

import torch
!pip install pytorch-ignite
class CnnRegressor(torch.nn.Module):
# Define the initialization method
  def __init__(self, batch_size, inputs, outputs):
# Initialize the superclass and store the parameters
    super(CnnRegressor, self).__init__()
    self.batch_size = batch_size
    self.inputs = inputs
    self.outputs = outputs  
# Define the input layer
# (input channels, output channels, kernel size)
    self.input_layer = Conv1d(inputs, batch_size,1)
    # Batch normalization
    self.input= torch.nn.BatchNorm1d(inputs) 
# Define a max pooling layer
    self.max_pooling_layer = MaxPool1d(1)
# Define another convolution layer
    self.conv_layer = Conv1d(batch_size, 128,1)
# Define a max pooling layer
    self.max_pooling_layer2 = MaxPool1d(1)
    self.flatten_layer = Flatten() 
# Define a linear layer
# (inputs, outputs)
    self.linear_layer = Linear(128, 64)   
# Finally, define the output layer
    self.output_layer = Linear(64, outputs)
       
# Define a method to feed inputs through the model
  def feed(self, input):
# Reshape the entry so it can be fed to the input layer
# Although weâ€™re using 1D convolution, it still expects a 3D array to process in a 1D fashion
    input = input.reshape((self.batch_size, self.inputs, 1))
# Get the output of the first layer and run it through the
# the ReLU activation function
    output = relu(self.input_layer(input))
# Get the output of the max pooling layer
    output = self.max_pooling_layer(output)
# Get the output of the second convolution layer and run it
# through the ReLU activation function
    output = relu(self.conv_layer(output))
# Get the output of the flatten layer
    output = self.flatten_layer(output)
# Get the output of the linear layer and run it through the
# ReLU activation function
    output = self.linear_layer(output)
# Finally, get the output of the output layer and return it
    output = self.output_layer(output)
    return output

def load_checkpoint(filepath):
    checkpoint = torch.load(filepath)
    model = checkpoint['model']
    print(model)
    model.load_state_dict(checkpoint['state_dict'])
    for parameter in model.parameters():
        parameter.requires_grad = False
    model.eval()
    return model

model = load_checkpoint('1116552_1dconv_reg')